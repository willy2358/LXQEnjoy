<!--terms: round, trick --->
<game name="shengji">
  <!--Poker: 
            术语：bid: 叫牌
                 draw: 摸牌
                 overbid:造反
                 trick: 一圈
                 round: 一局，从玩家拿到牌到决出胜负玩家，一局由一圈或多圈组成
                 void: 绝牌，没有一门牌
                 rank: 牌点
                 suit: 花色



            约定：m,n,k: 有确定数字， x,y,z无确定数字，在程序运行时确定。
            card, c:单张，确定牌
            x,y,z ：单张，不确定牌
            cards, cs：多张，确定牌
            xs,ys,zs：多张，不确定牌

            **牌色
              ctype: s:spade, h:heart, c:club,d:diamond
              方法：
              ctype_of(x)   
              如果x为列表，有时候取任意一个，有时候遍历每一个。
              用法：1）ctype_of="x" //取花色
                    2）value="ctype_of, x" //取花色，并赋值于value
                  *）取花色
                  *）取花色，判定
                  *）将花色，赋值于变量
                  *）取变量的花色
                  *) 花色相同判定
                  
                  
            **牌点
              cfigure: 牌的数字, 1 - 13（A - K)，21, jm：Joker Moon 小王;  22, js：Joker Sun 大王， 
              方法：
              cfigure_of(x)
              min_cfigure_of(xs)   //取x表示的变量的最小牌点数
              max_cfigure_of(xs)   //取x表示的变量的最大牌点数
              用法：1）cfigure_of="x" //取x的点数
                    2) value="cfigure_of,x" //取x的点数，并赋值给value
                    3）min_cfigure_of="xs"
                    4) value="min_cfigure_of,xs"
                    5) max_cfigure_of="xs"
                    6) value="max_cfigure_of,xs"

                  *）取牌点
                  *）取牌点，判定
                  *）将牌点，赋值于变量
                  *）取变量的牌点
                  *) 点数相等判定

            **牌面
              card: 表示法：ctype(一个字符）-cfigure，中间无横线"-"
                    c1-c13
                    d1-d13
                    h1-h13
                    s1-s13
                    j1,j2, 小王，大王
        
            **牌型
              ****同点
              通式：same_cfigure(x,n)  ：泛指有n个牌同点，x：牌的点数未确定，
              示例: 
                same_cfigure(2,4), 4个2；
                same_cfigure(5,2), 2个5
                same_cfigure(x,3), 任意点数牌3张，3张同点
                                              
              特例：
              single(n): 单牌, <=> same_cfigure(x,1)
              pair(n): 对子    <=> same_cfigure(x,2)
              triple(n): 三张，相同Figure <=> same_cfigure(x,3)
              quad(n): 四张，相同Figure  <=> same_cfigure(x,4)
              用法：
              <same_cfigure cards_var="var_x", count="n">

              ****同色，同花色牌
              通式：same_ctype(x)     //x表示的牌都是同花色
                   same_ctype(x:ctype)  //x表示的牌都是ctype的牌     
                   same_ctype(x|n) x表示的牌中，有n个是同花色
                   same_ctype(x:ctype|n) x表示的牌中，有n个是花色是ctype
                   same_ctype(m,n,k,...[:ctype]|n)

              特例：
              same_heart(x)  <=> same_ctype(x,"h")
              same_diamond(x)  <=> same_ctype(x,"d")
              same_club(x) <=> same_ctype(x,"c")
              same_spade(x) <=> same_ctype(x, "s")

              ****连牌  
              通式：seq(x,y) 从x开始，个数无限制, y>2 ,不必同花色
                   seq(x,y:ctype) 从x开始，个数无限制, y>2 ,同花色，花色确定
                   seq(x,y:x) 从x开始，个数无限制, y>2 ,同花色，花色任意
                   seq(x,y[:ctype]|x约束，约束)
                   seq(m,n,j,...[:ctype/x]) //（同花色）确定的连牌，m,n,j数字递增。

              特例：
              //同花色连牌
              seq_x   //任意花色
              seq_heart
              seq_diamond
              seq_spade
              seq_club
                *******多重数字连牌
                通式：seqm(m|x,y) 从x开始，个数无限制, y>2 ,不必同花色
                    seqm(m|x,y:ctype) 从x开始，个数无限制, y>2 ,同花色，花色确定，只有多副牌时才会出现
                    seqm(m|x,y:x) 从x开始，个数无限制, y>2 ,同花色，花色任意
                    seqm(m|x,y[:ctype]|x约束，约束), 只有多副牌时才会出现
                    seqm(m|m,n,j,...[:ctype/x]) //（同花色）确定的连牌，m,n,j数字递增。只有多副牌时才会出现
                示例:
                    seqm(2|1,2,3)   11,22,33
                    seqm(3|3,4) 333,444

              ****牌型组
              comp(m,n,k,.....): 牌型组，m,n,k确定，但无约束
              comp(x|y) : y张任意牌, x的约束在由y描述，支持&&,||
              comp(x,y,z[,u,v,w]|constraints)
              comp(xx,yyy,zzzz)
              comp(mmm,nn,k)
              comp(mm,n, xxxx)
              使用示例：
              <comp params="x,y,z" constraint_param_1="x的约束" 
                                    constraint_param_2="y的约束" 
                                    constraint_param_3="z的约束"/>
              <comp params="xx,yyy,z" constraint_param_1="x的约束" 
                                    constraint_param_2="y的约束" 
                                    constraint_param_3="z的约束"/>
              <comp params="3,yy,z" constraint_param_1="none" 
                                    constraint_param_2="y的约束" 
                                    constraint_param_3="z的约束"/>

              ****牌型操作：
                cpattern_of(x)
                cpattern_of(xs)

                *) 取牌型
                *) 牌型相同判定
              
      元函数/表达式：
      说明：以_as为后缀的函数中，参数是变量的值
      取点数：
      cfigure_of, 
      cfigure
      cfigure_as
      min_cfigure_of(cards)   //取x表示的变量的最小牌点数
      max_cfigure_of(cards)   //取x表示的变量的最大牌点数

      取花色：
      ctype_of, 用于属性名  ctype(m)，用于属性值
      ctype_as
      ctype

      取能级
      power_of(xs)
      power_of(x)
      power_as
      max_power_of(cards)

      取牌型
      cpattern_of(x)
      cpattern_of(xs)
      cpattern_as
      cpattern_type_of
      cpattern_name_of
      get_pattern_of_name
      get_pattern_of_type
      
      
      取数组,列表的元素
      cards[0]

      //取得cards的花色个数
      ctype_count_of(card)    
      ctype_count_of(cards)

      //是否有某花色牌
      cards_contain_ctype(cards, ctype)
      cards_not_contain_ctype(cards, ctype)

      cards_contain_ctype_as(cards, ctype)
      cards_not_contain_ctype_as(cards, ctype)

      //是否有某数字牌
      cards_contain_cfigure(cards, cfigure)
      cards_contain_cfigure_as(cards, cfigure)

      cards_not_contain_cfigure(cards, cfigure)
      cards_not_contain_cfigure_as(cards, cfigure)

      //是否全为某花色牌
      cards_all_ctype(cards, ctype)  return true/false
      cards_all_ctype_as(cards, ctype) return true/false

      //是否为某牌型
      cards_is_typed_pattern(cards, pattern_type)
      cards_is_named_pattern(cards, pattern_name)
      cards_is_pattern_as(cards, :(cards))

      cards_count_not_deal() return number
      cards_not_deal() return cards

      cards_of_ctype(cards, ctype) return cards 
      
      cards_in_cur_player_hand, return cards
      cards_out_on_table,  return cards
      cards_in_all_players_hand, return cards
      cards_in_other_players_hand return cards

      cards_of_ctype_in_cur_player_hands
      cards_of_ctype_in_other_players_hands
      cards_of_ctype_in_all_players_hands
      cards_of_ctype_out_on_table     
    
      //玩家是否有某牌色
      player_has_cards_of_ctype(ctype) == player_not_void
      player_has_cards_of_ctype_as(ctype) == player_not_void_as
      player_not_has_cards_of_ctype(ctype) == player_is_void
      player_not_has_cards_of_ctype_as(ctype) == player_is_void_as
      if_ctype_void //是否绝牌
      if_ctype_void_as
      is_player_void
      is_player_void_as

      //玩家是否有某数字牌
      player_has_cards_of_cfigure(cfigure)
      player_has_cards_of_cfigure_as(cfigure)
      player_not_has_cards_of_cfigure(cfigure)
      player_not_has_cards_of_cfigure_as(cfigure)

      //玩家是否有某牌型
      player_has_cards_of_named_pattern(pattern_name)
      player_not_has_cards_of_named_pattern(pattern_name)
      player_has_cards_of_typed_pattern(pattern_type)  
      player_not_has_cards_of_typed_pattern(pattern_type)
      is_player_has_named_pattern
      is_player_has_typed_pattern

      //取得指定张数的花色牌
      player_get_cards_of_ctype(ctype, count, candidate_ctype)
      player_get_cares_of_ctype_as(ctype, count, candidate_ctype)

      player_cards_in_hand()
      player_cards_count_in_hand()  return number


      //底牌
      cards_in_kitty()

      sum_score(cards)

      player_seatid(@player)

      
    返回值测试：

    相等/不相等
    ret_is, ret_not_is, 
    ret_as, ret_not_as:  

    小于/不小于
    ret_lt, ret_not_lt:  ret_less_than, ret_not_less_than
    ret_lt_as, ret_not_lt_as:

    大于/不大于
    ret_gt, ret_not_gt:  ret_greater_than, ret_not_greater_than
    ret_gt_as, ret_not_gt_as:
   
    //定义round变量
    <round_attr name="cur_level" value_type="int" init_value="2"/>

    //定义player变量
    <player_attr name="IsMainPlayer" value_type="bool"/>

    //条件测试, 测试结果为真，执行case的内部节点
    <case testee="card" cfigure_of="card" ret_as=":(cur_level)">
    </case>

    round属性：
    

    //条件测试嵌套
    <case>
      <case>
         //do 
      </case>
    </case>

    <set property="x" value="newValue">
      <cases>
      </cases>
    </set>

    <conditions>
      <case/>
      <case/>
      <update>
      </update>
    </conditions>

    //找到Player,然后进一步判断
    <find_player>
      <case/>|<cases/>
      
    <find_player>

    //找到Player, 设置其属性
    <find_player>
      <update />
    </find_player>

    函数返回值类型：
    1. True/False
    2. Cards
    3. Count

    判断语句：
    1. objT = find object of condtionT(在某些context下，objT为已知，此句可省略）
       if objT.PropT == ValT
       then 
           objA = find object of conditionY
           objA.propX = Val
       视角：某条件满足，会影响那些对象
       <case value_of="objT.PropT" ret_is="ValT">
        <set>

        </set>
        //else 节点可选
        <else>
          <set>
          </set>
        </else>
       </case>

       <cases ttype="or|and">
        <case>
        </case>
        <case>
        </case>
        <set>
        </set>
        <else>
          <set>
          </set>
        </else>
       </cases>
       
    
    2. objA = find object of conditionY
       objA.propX = Val when 
                        objT = find object of condtionT(在某些context下，objT为已知，此句可省略）
                        and objT.PropT == ValT
       视角：要设置对象A的属性，需要满足什么样的条件
       <let>
        <when ttype="or|and">
          <case>
          </case>
        </when>
       </let>

       //设置属性可以是 let的属性，也可以用单个节点列出
       //当有一个条件时，这个条件可以通过when的属性来表示，也可以用一个case来表达
       //当有多个条件时，各条件用多个case来表达

    
       
       
    关键词：
    trick_winner ： 一圈的赢家， get the player who won one trick
    card_played_out: 一个玩家打出的一张牌
    cards_played_out: 一个玩家打出的几张牌（包括一张）
    @cards_trick: 一圈打出的所有牌
    
    @trick_init_player
    @trick_init_cards， 一圈的起始牌
    @prev_player 上家
    @prev_cards 最近前面出的牌，有可能不是上家的牌

    @score_cards 分数牌

    
    @trick.max_power_player
    
    @round
    @round.init_drawer : 起始摸牌人
    @card
    @cards
    @drawn_card  :摸到的一张牌
    @drawn_cards :摸到的牌（有可能是一张）
    
    @player.played_cards
    
    @single
    
    @any
    @any_ctype / @ctype_any
    @ctype_c
    @ctype_d
    @ctype_h
    @ctype_s

    属性操作符：.
    <case value_of="@trick_winner.IsAttacter" ret_is="true"/>    
    value_of: get_value_of

    固定属性
    @card.power
    @cards.power
    @card(s).leading

    @kitty_cards
    @kitty.cards

    @act_card :执行动作凭持的牌
    @act_cards

    @selected_cards
    

    变量：
    定义：
       var="p1", 字母，数字，下划线
    引用变量或关键词:@p1, @trick_winner
    
    变量别名：
    定义：<alias name="card" ref="card_played_out"/>
          <alias name="cards" ref="cards_played_out"/>

    <find_player player="@trick.max_power_player">
    </find_player>

    <let property="@round.winners" value=":(find_players(IsDefender=true))"/>
  -->
  
</game>